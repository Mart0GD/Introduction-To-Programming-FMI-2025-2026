# Лек увод
-----------------------------------
## Какво е масив?

Масив е **линейна** структура от данни, която ни позволява съхраняването на и достъпа до произволен брой елементи от паметта, като за момента ще разгледаме 
единствено и само масиви с константен размер, който ще знаем по времето на компилация.  

**линейна** --> всеки елемент има единствен предходен и следващ елемент, като имаме и съответно наредба;

### Как създаваме масив в **C**:
**а) Синтаксис**

<p>
  
```c
// константи литерали са стойности като 1, 15, 27.
// декларация
<type> <name>[<constant_literal>]; // constant_literal е винаги положително число!

unsigned myArr[5];

// инициализация
<type> <name>[] = {el_1, el_2, .., el_n};
int myArr[] = {1, 2, 3, 4};
```
</p>

**б) Как достъпваме елемент**

<p>
  
```c
int main()
{

  // синтаксис
  <name_of_array>[<index>]; // reminder: елементите се броят от индекс 0
  
  int myArr[] = {8, 7, 19, 55};
  printf("%d", myArr[2]);

  myArr[2] = myArr[0] + myArr[1];

  return 0;
}
```
</p>

<img width="1534" height="494" alt="image" src="https://github.com/user-attachments/assets/3f64c73f-febb-43c9-895a-35b585c19fd5" />

### Как да изчислим размера на масив:

~~~
// за целта на примера приемете, че int e с размер 4 byte-а
int arr[5]; 

int size = sizeof(arr) / sizeof(arr[0]);
~~~

**Много важно**  
Тази имплементация важи единствено и само за масиви с константна дължина, в чиито scope (област на действие се намираме);

### Итерация на елементи в масив:
<img width="1545" height="566" alt="image" src="https://github.com/user-attachments/assets/459e4e36-64c8-43de-b011-03cff1f54edf" />

<img width="1514" height="520" alt="image" src="https://github.com/user-attachments/assets/53e56c6d-5e7e-4c0c-b748-f16960c3eea0" />

### Предпроцесор. Макроси тип обект.

**а) Предпроцесор и предпроцесорни директиви**

Предпроцесорът е програма, обработваща текст. Стандартът на езика С(и С++), задължава компилаторите да предоставят предпроцесор. 
Предпроцесорът обработва така наречените **предпроцесорни директиви** и извършва текстови трансформации. Предпроцесорните директиви
са текст, започващ с **#**, последван от някаква команда към предпроцесора.

**Пример за предпроцесорни директиви**
* **#include**
* **#define**
* **#undefine**
* **#pragma**

**б) Макроси. Макрос тип обект**

А какво е **макрос**? Отговорът в рамките на този курс е **нищо страшно**. **Макросът** е резултатът от предпроцесорните директиви **#define**.
Когато предпроцесорът види директива тип **#define X Y**,  той замества **X** с **Y**

Сега е моментът, в който да видим защо това ни вълнува. Досега подавахме число-размер на статичен масив от типа на 1, 7, 16 и т.н. Това са така-
наречените литерали. На първо място в по-голям код те не ни говорят нищо, не са достатъчно изчерпателни. Защо примерно не използваме константна променлива?
Стандартът в С изисква размерът на статичен масив да бъде константен израз, известен като стойност още по време на компилация. Ето защо някои компилатори не биха приели следното:

<p>
  
```c
int main()
{
  const int size = 10;
  int arr[size]; // undefined
  return 0;
}
```
</p>

**Вместо това, ние ще използваме макроси! ;)**

<p>
  
```c
// #define X Y <=> rule: if you see X, replace it with Y
#define ARRAY_SIZE 10
int main()
{
  const int size = 10;
  int arr[ARRAY_SIZE];

  printf("%d", ARRAY_SIZE);
  return 0;
}
```
</p>

<img width="1577" height="511" alt="image" src="https://github.com/user-attachments/assets/02382baa-2945-44e1-b7f3-6d7c2bbd0303" />

### И за финал...(преход към указатели)
Какво мислите, че ще се отпечата, ако напишем:

<p>
  
```c
#define ARRAY_SIZE 10
int main()
{
  const int size = 10;
  int arr[] = {1,2,3};

  printf("%d", arr);
  return 0;
}
```
</p>

<img width="1623" height="536" alt="image" src="https://github.com/user-attachments/assets/86962cf7-1636-48ed-bd1d-06e25a74564e" />




