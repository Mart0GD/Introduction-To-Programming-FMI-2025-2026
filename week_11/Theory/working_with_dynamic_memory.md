# Функции за боравене с динамична памет
Всички от долуспоменатите функции са дефинирани в header-a ***<stdlib.h>***

**а) void\* malloc(size_t size)**

Функция връщаща указател към ***неинициализиран*** блок от динамична памет с размер **size**. В случай, че функцията не успее да задели памет, тя връща ***NULL pointer***.

* **size:** броят байтове динамична памет, който изискваме

**б) void\* calloc(size_t num, size_t size)**

Функция връщаща указател към масив в динамичната памет с **num** елемента, всеки от тях с размер **size**. ***Инициализира*** всеки байт от масива с 0(нула).
Ако **size = 0**, то поведението на **calloc** е ***undefined behaviour**. Може да върне **NULL pointer**, а може и да върне ненулев указател.

* **num:** брой елементи в масива
* **size:** размер в байтове на типа, който ще съдържа масива

**в) void\* realloc(void \*ptr, size_t new_size)**

Функция, която презаписва даден блок от динамична памет. Ако **ptr** не е **NULL**, то трябва да сочи към памет предходно запазена с **malloc**, **calloc** или **realloc**
и да не е била освобождаване с **free**. В противен случай **realloc** има **undefined behaviour**. Презаписването се осъществява по един от следните два начина:

* разширява(смалява) текущия блок от памет. Съдържанието на оригиналния блок от памет остава непроменено, докато новозаделения блок памет, който добавяме е с **undefined** стойности.

* заделя се нов блок памет и се копират **min(old_size, new_size)** байта от оригиналният блок памет в новия. 

Ако няма достатъчно свободна памет **realloc** не освобождава блока от памет, към който **ptr** оригинално сочи и връща **NULL**.
Ако **ptr** е **NULL**, то извикването на **realloc** е еквивалентно на **malloc(new_size)**.
Ако **new_size** е 0(нула), то поведението **undefined**.

**г) void free(void \*ptr)**

Функция, която освобождава блок от памет, предходно запазен посредством **malloc**, **calloc** или **realloc**. Ако паметта сочена от **ptr** не е заделена с една от преходно 
изброените функции, то поведението на **free** е **undefined**. Ако **ptr** е **NULL**, то **free** не прави нищо. Ако повторно извикваме **free** върху указател, сочещ към вече освободен
блок от памет, то поведението отново е **undefined**. Ако опитаме да дереференцираме указател, върху който е извикана **free** поведението е **undefined**, освен ако няма повторно извикване на 
функция, заделяща динамична памет.

## 101 работа с динамична памет

За да избегнем оттечка на памет(загуба на динамична памет), след извикване на която и да е от функциите, заделящи памет, извикваме free() върху съответния указател. В противен случай доц. Армянов ни къса и плачем. За да избегнем това, правим следното и го помним като ЕГН–то си:

<p>
  
```c
#include <stdlib.h>
int main() {
  int* ptr = malloc(sizeof(int)); // напишем ли malloc/calloc/realloc, веднага пишем free(ptr)
                                  // и над free() пишем логиката, която искаме програмата ни да изпълнява.
  
  // тук правим каквото искаме програмата ни да прави.
  
  free(ptr);
  ptr = NULL; // за да избегнем undefined behaviour
  return 0;
}
```
</p>
