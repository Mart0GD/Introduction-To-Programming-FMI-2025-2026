# Функции
Функциите са конструкции в С, които асоциират име с някакъв блок от код(тяло на функция), който се изпълнява при извикването на това име. Чрез тях можем да създаваме отделни модули от логика, които да преизползваме многократно. Всяка програма започва от ***main()*** и или терминира, или извиква други функции. Всъщност, карайки този курс досега ние използвахме немалко функции вече. Например ***printf, scanf, pow, sqrt.***. Те също заемат някакво място в паметта, което и бива отредено по време на **linking** фазата на компилация.

## Декларация и дефиниция
Както при променливите, така и фунцкиите подлежат на декларация и дефиниция. 

**а) Декларация, синтаксис**

<p>
  
```c
// declarations
<return_type> <function_name> <parameter-list> 

double pow(double number, unsigned power);

short charToNumber(char ch);

void myFunc();
```
</p>

**б) Дефиниция, синтаксис**

<p>
  
```c
// declarations
<return_type> <function_name> <parameter-list> 
<compound_statement>

long long powIntegral(int number, unsigned power);

void charToNumber(char ch);

long long pow(int number, unsigned power)
{
  for (int i = 0; i < power; ++i)
  {
    number *= number;
  }

  return number;
}

void charToNumber(char c)
{
   printf("%d", c);
}

```
</p>

## Тип на връщане
Можем да зададем като тип на връщане всеки един от изучените от досега вградени типове като ***char, short, int, long, float, double, long double И void***
Задавайки типа на връщане като **void** указваме, че тази функция няма да връща НИЩО. 

## Списък от параметри

**а) Формални параметри vs. реални аргументи**
Списъкът от аргументи указва броя и типа на аргументите, които ще подаваме. Важно е да правим разлика между термините ***формални параметри*** и ***реални аргументи***.
В прототипът на една функция, например:

<p>
  
```c
// тук hp и yearOfProd са формални параметри
float calculateCarTax (int hp, int yearOfProd) {
// some implementation
  return tax;
}

int main() {
  // при извикването на функцията подаваме реални аргументи или просто - аргументи
  float tax = calculateCarTax(201, 2009);
  return 0;
}

```
</p>

**б) void като параметът на функция**

Когато напишем функция с единствен параметър ***void*** без идентификатор, то указваме експлицитно, че тази функция няма да приема никакви аргументи.
<p>
  
```c
void printCourseName(void) {
  printf("Intro_to_programming\n");
}

int main() {
  // при извикването на функцията подаваме реални аргументи или просто - аргументи
  printCourseName();
  return 0;
}

```
</p>

**в) лист от параметри завършващ с ellipsis (...) или просто variadic function**
В С ,при извикване на фунцкии, трябва да спазваме прототипа им и да подаваме точния желан брой аргументи, както и да са от съвместим тип. Понякога, обаче, искаме да можем да подаваме неопределен брой аргументи. В рамките на този курс просто ще се погрижим да знаете за съществуването на такъв функции, но не и за компетентността да боравите с тях. За да напишем такава функция използваме следния синтаксис

<p>
  
```c

float calcAverage(int arg1, ...) {
// some implementation
}

```
</p>

<img width="1553" height="648" alt="image" src="https://github.com/user-attachments/assets/bf9b4516-6738-48b8-bfa3-386710256faf" />

## Подаване на аргумент по стойност. Подаване на аргумент по адрес
Когато подаваме някаква променлива **var** като аргумент на фунцкия, то в паметта се създава копие на **var**, с което боравим. Когато се нуждаем от някаква междинна сметка и не искаме да модифицираме оригинална стойност, това е желано поведение. Понякога, обаче, бихме искали работата на функцията да се отрази върху променлива, която сме подали като неин аргумент. Един начин да постигнем това е да използваме ***return*** стойността на нашата функция.

<p>
  
```c
// calculate the bruto salary via some factors
float getSalaryBruto(...) { -//-}

// calculate the neto salary via some factors
float getSalaryNeto(float brutoSalary, ...) { -//-}

int main()
{
  float salary = getSalaryBruto(<some_args>);
  // тук с присвояване постигаме желания резултат
  salary = getSalaryNeto(salary, <some_args>);
  return 0;
}

```
</p>

Но такова решение ни лимитира. Какво става, ако искаме действието на функцията да се отрази на повече от един аргумент? За такива ситуации можем да използваме така-нареченото подаване на аргумент по адрес/указател. Вместо да подаваме променливата като аргумент на фунцкията, подаваме нейният адрес в паметта и така манипулираме директно стойностите записани в нея. За целта трябва да променим сигнатурата/прототипа на нашата функция, така че да приема адреси. След типа на аргумент, който приема функцията поставяме следния символ *.

<p>
  
```c

void foo(int* arg1, int* arg2, ...)
{
  // пред аргумента поставяме отново символ * към променливата-адрес, за да отидем на това място в  паметта
  *arg1+=2;
  *arg2+=2;  
}

int main()
{
  int a = 10, b = 15;
  // поставяме & за да вземем адреса на променливата
  foo(&a, &b);
  printf("a = %d; b = %d\n", a,b);
  return 0;
}

```
</p>

<img width="1553" height="648" alt="image" src="https://github.com/user-attachments/assets/27d4249c-fa61-4de2-9a29-a95811f1d8c4" />
