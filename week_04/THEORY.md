# Представяне на цели числа в паметта

## One's complement  

Един от най-старите методи за представяне на цели числа е **one's complement**.  
При него отрицателните числа се получават чрез **обръщане на всички битове** на положителното число.  
Методът се нарича така, защото при сумиране на число и неговата отрицателна стойност се получават само единици.  
One's complement е използван до края на 80-те години.

### Пример: 8-битово представяне (one's complement)

|   | + | − |
|---|---|---|                 
| 0 | 00000000 | 11111111 | — има +0 и −0 
| 1 | 00000001 | 11111110 |
| 2 | 00000010 | 11111101 |
| 3 | 00000011 | 11111100 |
| 4 | 00000100 | 11111011 |
| 5 | 00000101 | 11111010 |
| 6 | 00000110 | 11111001 |
| 7 | 00000111 | 11111000 |

> **Забележка:** Вижда се двойният нулев елемент (+0 и −0).

---

### Пример за аритметика (one's complement)

**Пример 1: 6 − 19**
~~~
  00000110   6
− 00010011  19
=============
1 11110011  −12  <- end-around borrow
− 00000001   1
=============
  11110010  −13  <- правилен резултат
~~~

**Пример 2: 22 − (−0)**
~~~
  00010110   22
− 11111111   −0
=============
1 00010111   23  <- end-around borrow
− 00000001    1
=============
  00010110   22  <- правилен резултат
~~~

> One's complement изисква корекция при borrow, защото има двойна нула.

---
## Two's complement  

Two's complement е **модерният и най-широко използван метод** за представяне на цели числа.  
Отрицателните числа се получават чрез **обръщане на всички битове** и **добавяне на 1**.

### Пример: −6

1. +6 → `00000110`  
2. Обръщаме всички битове → `11111001`  
3. Добавяме 1 → `11111010`  

> Резултат: `11111010` = −6 ✅

---
### Пример: 0
~~~
0 → 00000000
Обръщане → 11111111
Добавяне на 1 → 00000000
~~~

> Проблемът с двете нули (one's complement) е решен.

---

### Диапазони

- **One's complement (n бита):** `[-(2^(n-1)-1) ... 2^(n-1)-1]`  
  - 8 бита: `[-127 ... 127]`  
  - Има два нулеви елемента (+0 и −0).  

- **Two's complement (n бита):** `[-2^(n-1) ... 2^(n-1)-1]`  
  - 8 бита: `[-128 ... 127]`  
  - Има само една нула, затова най-отрицателното число (-128) няма противоположно число.  
  - В C/C++ работа с най-отрицателното число при обръщане се счита за **undefined behavior**.

> **Забележка:** Това обяснява защо `-128` остава `-128`, ако се опитате да го обърнете в two's complement, а не се превръща в +128.
